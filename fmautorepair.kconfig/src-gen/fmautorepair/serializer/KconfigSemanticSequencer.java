/*
 * generated by Xtext 2.9.1
 */
package fmautorepair.serializer;

import com.google.inject.Inject;
import fmautorepair.kconfig.AndLiteral;
import fmautorepair.kconfig.Choice;
import fmautorepair.kconfig.Config;
import fmautorepair.kconfig.ConfigLiteral;
import fmautorepair.kconfig.Default;
import fmautorepair.kconfig.Dependency;
import fmautorepair.kconfig.Expr;
import fmautorepair.kconfig.Import;
import fmautorepair.kconfig.KconfigExpr;
import fmautorepair.kconfig.KconfigPackage;
import fmautorepair.kconfig.Model;
import fmautorepair.kconfig.NeqLiteral;
import fmautorepair.kconfig.OrLiteral;
import fmautorepair.kconfig.Prompt;
import fmautorepair.kconfig.Range;
import fmautorepair.kconfig.Select;
import fmautorepair.kconfig.Type;
import fmautorepair.services.KconfigGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class KconfigSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private KconfigGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == KconfigPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case KconfigPackage.AND_LITERAL:
				sequence_AndLiteral(context, (AndLiteral) semanticObject); 
				return; 
			case KconfigPackage.CHOICE:
				sequence_Choice(context, (Choice) semanticObject); 
				return; 
			case KconfigPackage.CONFIG:
				sequence_Config(context, (Config) semanticObject); 
				return; 
			case KconfigPackage.CONFIG_LITERAL:
				sequence_ConfigLiteral(context, (ConfigLiteral) semanticObject); 
				return; 
			case KconfigPackage.DEFAULT:
				sequence_Default(context, (Default) semanticObject); 
				return; 
			case KconfigPackage.DEPENDENCY:
				sequence_Dependency(context, (Dependency) semanticObject); 
				return; 
			case KconfigPackage.EXPR:
				sequence_Expr(context, (Expr) semanticObject); 
				return; 
			case KconfigPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case KconfigPackage.KCONFIG_EXPR:
				sequence_PrimaryLiteral(context, (KconfigExpr) semanticObject); 
				return; 
			case KconfigPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case KconfigPackage.NEQ_LITERAL:
				sequence_NeqLiteral(context, (NeqLiteral) semanticObject); 
				return; 
			case KconfigPackage.OR_LITERAL:
				sequence_OrLiteral(context, (OrLiteral) semanticObject); 
				return; 
			case KconfigPackage.PROMPT:
				sequence_Prompt(context, (Prompt) semanticObject); 
				return; 
			case KconfigPackage.RANGE:
				sequence_Range(context, (Range) semanticObject); 
				return; 
			case KconfigPackage.SELECT:
				sequence_Select(context, (Select) semanticObject); 
				return; 
			case KconfigPackage.TYPE:
				sequence_Type(context, (Type) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Expr returns AndLiteral
	 *     Expr.Expr_1_0 returns AndLiteral
	 *     NeqLiteral returns AndLiteral
	 *     NeqLiteral.NeqLiteral_1_0 returns AndLiteral
	 *     SecondaryLiteral returns AndLiteral
	 *     AndLiteral returns AndLiteral
	 *     AndLiteral.AndLiteral_1_0 returns AndLiteral
	 *     OrLiteral returns AndLiteral
	 *     OrLiteral.OrLiteral_1_0 returns AndLiteral
	 *     PrimaryLiteral returns AndLiteral
	 *
	 * Constraint:
	 *     (left=AndLiteral_AndLiteral_1_0 right=OrLiteral)
	 */
	protected void sequence_AndLiteral(ISerializationContext context, AndLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KconfigPackage.Literals.KCONFIG_EXPR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KconfigPackage.Literals.KCONFIG_EXPR__LEFT));
			if (transientValues.isValueTransient(semanticObject, KconfigPackage.Literals.KCONFIG_EXPR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KconfigPackage.Literals.KCONFIG_EXPR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndLiteralAccess().getAndLiteralLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndLiteralAccess().getRightOrLiteralParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Choice returns Choice
	 *
	 * Constraint:
	 *     (Choice='choice' configs+=Config+)
	 */
	protected void sequence_Choice(ISerializationContext context, Choice semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConfigLiteral returns ConfigLiteral
	 *
	 * Constraint:
	 *     (conf=[Config|ID] | string=STRING)
	 */
	protected void sequence_ConfigLiteral(ISerializationContext context, ConfigLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Config returns Config
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (
	 *             type=Type | 
	 *             prompts+=Prompt | 
	 *             ranges+=Range | 
	 *             dependencies+=Dependency | 
	 *             selects+=Select | 
	 *             defaults+=Default
	 *         )*
	 *     )
	 */
	protected void sequence_Config(ISerializationContext context, Config semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Default returns Default
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             value=Expr | 
	 *             trival='n' | 
	 *             trival='m' | 
	 *             trival='y' | 
	 *             hex=HEX_TERMINAL | 
	 *             int=INT
	 *         ) 
	 *         KconfigExpr=Expr?
	 *     )
	 */
	protected void sequence_Default(ISerializationContext context, Default semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Dependency returns Dependency
	 *
	 * Constraint:
	 *     deps=Expr
	 */
	protected void sequence_Dependency(ISerializationContext context, Dependency semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KconfigPackage.Literals.DEPENDENCY__DEPS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KconfigPackage.Literals.DEPENDENCY__DEPS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDependencyAccess().getDepsExprParserRuleCall_1_0(), semanticObject.getDeps());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns Expr
	 *     Expr.Expr_1_0 returns Expr
	 *     NeqLiteral returns Expr
	 *     NeqLiteral.NeqLiteral_1_0 returns Expr
	 *     SecondaryLiteral returns Expr
	 *     AndLiteral returns Expr
	 *     AndLiteral.AndLiteral_1_0 returns Expr
	 *     OrLiteral returns Expr
	 *     OrLiteral.OrLiteral_1_0 returns Expr
	 *     PrimaryLiteral returns Expr
	 *
	 * Constraint:
	 *     (left=Expr_Expr_1_0 right=NeqLiteral)
	 */
	protected void sequence_Expr(ISerializationContext context, Expr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KconfigPackage.Literals.KCONFIG_EXPR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KconfigPackage.Literals.KCONFIG_EXPR__LEFT));
			if (transientValues.isValueTransient(semanticObject, KconfigPackage.Literals.KCONFIG_EXPR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KconfigPackage.Literals.KCONFIG_EXPR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExprAccess().getExprLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExprAccess().getRightNeqLiteralParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     importedNamespace+=QualifiedName
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (Choices+=Choice | Sources+=Import | configs+=Config)+
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns NeqLiteral
	 *     Expr.Expr_1_0 returns NeqLiteral
	 *     NeqLiteral returns NeqLiteral
	 *     NeqLiteral.NeqLiteral_1_0 returns NeqLiteral
	 *     SecondaryLiteral returns NeqLiteral
	 *     AndLiteral returns NeqLiteral
	 *     AndLiteral.AndLiteral_1_0 returns NeqLiteral
	 *     OrLiteral returns NeqLiteral
	 *     OrLiteral.OrLiteral_1_0 returns NeqLiteral
	 *     PrimaryLiteral returns NeqLiteral
	 *
	 * Constraint:
	 *     (left=NeqLiteral_NeqLiteral_1_0 right=SecondaryLiteral)
	 */
	protected void sequence_NeqLiteral(ISerializationContext context, NeqLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KconfigPackage.Literals.KCONFIG_EXPR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KconfigPackage.Literals.KCONFIG_EXPR__LEFT));
			if (transientValues.isValueTransient(semanticObject, KconfigPackage.Literals.KCONFIG_EXPR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KconfigPackage.Literals.KCONFIG_EXPR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNeqLiteralAccess().getNeqLiteralLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getNeqLiteralAccess().getRightSecondaryLiteralParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns OrLiteral
	 *     Expr.Expr_1_0 returns OrLiteral
	 *     NeqLiteral returns OrLiteral
	 *     NeqLiteral.NeqLiteral_1_0 returns OrLiteral
	 *     SecondaryLiteral returns OrLiteral
	 *     AndLiteral returns OrLiteral
	 *     AndLiteral.AndLiteral_1_0 returns OrLiteral
	 *     OrLiteral returns OrLiteral
	 *     OrLiteral.OrLiteral_1_0 returns OrLiteral
	 *     PrimaryLiteral returns OrLiteral
	 *
	 * Constraint:
	 *     (left=OrLiteral_OrLiteral_1_0 right=PrimaryLiteral)
	 */
	protected void sequence_OrLiteral(ISerializationContext context, OrLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KconfigPackage.Literals.KCONFIG_EXPR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KconfigPackage.Literals.KCONFIG_EXPR__LEFT));
			if (transientValues.isValueTransient(semanticObject, KconfigPackage.Literals.KCONFIG_EXPR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KconfigPackage.Literals.KCONFIG_EXPR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrLiteralAccess().getOrLiteralLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrLiteralAccess().getRightPrimaryLiteralParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns KconfigExpr
	 *     Expr.Expr_1_0 returns KconfigExpr
	 *     NeqLiteral returns KconfigExpr
	 *     NeqLiteral.NeqLiteral_1_0 returns KconfigExpr
	 *     SecondaryLiteral returns KconfigExpr
	 *     AndLiteral returns KconfigExpr
	 *     AndLiteral.AndLiteral_1_0 returns KconfigExpr
	 *     OrLiteral returns KconfigExpr
	 *     OrLiteral.OrLiteral_1_0 returns KconfigExpr
	 *     PrimaryLiteral returns KconfigExpr
	 *
	 * Constraint:
	 *     confslit+=ConfigLiteral
	 */
	protected void sequence_PrimaryLiteral(ISerializationContext context, KconfigExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Prompt returns Prompt
	 *
	 * Constraint:
	 *     (value=STRING KconfigExpr=Expr?)
	 */
	protected void sequence_Prompt(ISerializationContext context, Prompt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Range returns Range
	 *
	 * Constraint:
	 *     (
	 *         (((ifrom=SIGNED_INT | iconfrom=[Config|ID]) (ito=SIGNED_INT | iconfto=[Config|ID])) | (hfrom=HEX_TERMINAL hto=HEX_TERMINAL)) 
	 *         KconfigExpr=Expr?
	 *     )
	 */
	protected void sequence_Range(ISerializationContext context, Range semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Select returns Select
	 *
	 * Constraint:
	 *     (select=[Config|ID] Expr=Expr?)
	 */
	protected void sequence_Select(ISerializationContext context, Select semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Type
	 *
	 * Constraint:
	 *     (
	 *         (type='string' tprompt=STRING?) | 
	 *         ((type='bool' | type='tristate' | type='int' | type='hex') tprompt=STRING? KconfigExpr=Expr?) | 
	 *         ((type='def_bool' | type='def_tristate') def=Expr KconfigExpr=Expr?)
	 *     )
	 */
	protected void sequence_Type(ISerializationContext context, Type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
